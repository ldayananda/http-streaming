@startuml

header PlaylistLoader sequences
title PlaylistLoader sequences: Master Manifest and Alternate Audio

Participant "MasterPlaylistController" as MPC #green
Participant "PlaylistLoader: constructor" as PLc
Participant "PL: load()" as load
Participant "PL: start()" as start
Participant "MasterPlaylistLoader\nloadedplaylist handler" as lpH
Participant "MasterPlaylistLoader\nloadedmetadata handler" as lmH
  note over lmH, lpH #white: This is located in the MasterPlaylistController
Participant "media()" as media
Participant "external server" as ext #red
Participant "m3u8Parser" as parser #orange
Participant "haveMetadata()" as haveMetadata
Participant "mainSegmentLoader" as SL #blue
Participant "mediaGroups" as mG #purple
Participant setupFirstPlay #green
Participant Tech #lightblue

Participant "child alt audio PlaylistLoader\nloadedplaylist handler" as clpH
Participant "child alt audio PlaylistLoader\nloadedmetadata handler" as clmH
  note over clmH, clpH #white: This is located in MediaGroups

== Initialization ==

MPC -> PLc : setting up MasterPlaylistLoader
note left #lightyellow
  sets up mediaupdatetimeout
  handler for live playlist staleness
end note
note over PLc #lightgray: state = 'HAVE_NOTHING'

MPC -> load: calls

load -> start : calls
note left: not started yet
note over start #lightgray: started = true

== Requesting Master Manifest ==

start -> ext: xhr request for master manifest
ext -> start : response with master manifest
start -> parser: parse master manifest
parser -> start: object representing manifest
start -> start: set loader's master playlist
note over start #lightgray: state = 'HAVE_MASTER'
note left: trigger 'loadedplaylist' on master loader

== Requesting Video Manifest ==

start -> lpH: handling loadedplaylist
lpH -> media : select initial (video) playlist
note over media #lightgray: state = 'SWITCHING_MEDIA'

media -> ext : request child manifest
ext -> media: child manifest returned
media -> haveMetadata: calls
note over haveMetadata #lightgray: state = 'HAVE_METADATA'

haveMetadata -> parser: parse child manifest
parser -> haveMetadata: object representing the child manifest
haveMetadata -> haveMetadata: update loader's master and media playlists

opt live
  haveMetadata -> haveMetadata
  note left #lightyellow: setup mediaupdatetimeout
end

haveMetadata -> haveMetadata
note left
  trigger 'loadedplaylist' on
  master loader. This does not
  end up requesting segments
  at this point.
end note

haveMetadata -> lpH : "loadedplaylist handler"
lpH -> lpH : "setup durationchange handler"

== Requesting Video Segments ==

haveMetadata -> media: return
note left: trigger 'loadedmetadata' on master loader

media -> lmH: handling 'loadedmetadata'

opt vod and preload !== 'none'
  lmH -> SL: set playlist on mainSegmentLoader
  note left #lightgray: updates mainSegmentLoader.playlist
  lmH -> SL: call load on mainSegmentLoader
  note left #lightgray
    This does nothing as mimeTypes
    have not been set yet.
  end note
end

== Initializing Media Groups, Choosing Active Tracks ==

lmH -> mG: setupMediaGroups

group initialize media groups
  mG -> PLc: create child playlist loader for alt audio
  note left #lightyellow: state = 'HAVE_NOTHING'

  note left #lightgray
    setup 'loadedmetadata' and 'loadedplaylist' listeners
    on child alt audio playlist loader
  end note
  mG -> Tech: add audioTracks to Tech
end

mG -> mG: activeGroup and audio variant selected
mG -> mG: enable activeTrack, call onTrackChanged
note left #lightgray
  There is no activePlaylistLoader at this point,
  but there is an audio playlistLoader
end note

mG -> SL: reset mainSegmentLoader
note left #lightgray: Clears buffer, aborts all inflight requests

== Requesting Alternate Audio Manifest ==

mG -> mG: call startLoaders
note left #lightgray
  sets the activePlaylistLoader to be
  the alt audio playlist loader
end note
mG -> load: call load on alt audio playlistLoader
load -> start
note left #lightyellow: child playlistLoader: started = true
start -> ext: request alt audio media manifest

start -> lmH: return
lmH -> MPC: calls setupSourceBuffers
note left #lightgray
  This will set mimeType.
  Segments can be loaded from now on.
end note

lmH -> MPC: calls setupFirstPlay
note left #lightgray
  Immediate exit since the player
  is paused
end note

ext -> start: responds with child manifest
start -> parser: parse child manifest
parser -> start: object representing child manifest returned
note left #lightyellow: state = 'HAVE_MASTER'
note right #lightgray: Infer a master playlist

start -> haveMetadata
note left #lightyellow: state = 'HAVE_METADATA'
haveMetadata -> parser: parsing the child manifest again
note left #lightgray
  update child playlistLoader's
  master and media references
end note

== Requesting Alternate Audio Segments ==

haveMetadata -> haveMetadata
note left
  trigger 'loadedplaylist' on child playlistLoader
end note
haveMetadata -> clpH: child playlistLoader handles 'loadedplaylist'
note left #lightgray: set playlist on audioSegmentLoader

start -> start
note left: trigger 'loadedmetadata' on child playlist loader
start -> clmH: handling 'loadedmetadata'
clmH -> SL: calls playlist
clmH -> SL: calls load
SL -> ext: requests media segments

@enduml
